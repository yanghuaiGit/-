<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/307027 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="588"/>

<div>
<span><div><div>本次RenntrantLock分析主要包括如下模块：</div><ul><li><div><font color="#E30000"><b>ReentrantLock锁结构</b></font></div></li><li><div><font color="#E30000"><b>公平及非公平体现之处</b></font></div></li><li><div><font color="#E30000"><b>lock流程</b></font></div></li><li><div><font color="#E30000"><b>unlock流程</b></font></div></li><li><div><font style="color: rgb(227, 0, 0);"><b>condition模块</b></font></div></li></ul><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>一：ReentrantLock源码框架如下所示（第一次画这种图，可能不正规，可以百度去看看框架图）<br/></div><div><img src="ReebtrantLock源码分析_files/Image.png" type="image/png" data-filename="Image.png"/></div><div>主要结构如上图</div><div>reentrantlock实现了lock接口的lock，unlock等主要方法，通过其内部类syc继承abstractQueueSynchronizer进行实现的。</div><div>abstractQueueSynchronizer的作用主要是为lock失败添加了一个队列，以及相关操作，其内部主要也是两个内部类，Node以及Condition</div><div>abstractQueueSynchronizer进行的一个安全性添加队列以及删除节点（准确的说不是删除，只是将其引用变为null，交由虚拟机GC时删除），对应于加锁失败以及唤醒锁，获得锁操作。</div><div><br/></div><div>二：公平以及非公平体现之处：</div><div>首先要知道公平以及非公平的区别，才能了解源码实现的区别，知道为什么要这样设计。</div><div>一般理解为：在对reentrantlock锁定的资源进行多线程竞争时，未竞争到的会被添加到AQC的同步队列（只有调用lock方法，失败才会添加队列中，trylock只会返回true或者false。AQC还有一个等待队列是Condition使用的）。那么非公平以及公平的区别就在于同步队列获取锁以及后续第一次来尝试获取锁的线程之间的竞争了。</div><div>公平锁在锁被释放之后，Release操作只会唤醒同步队列的第一个waitstatus为&lt;=0的Node所对应的Thread。</div><div><font style="color: rgb(227, 0, 0);"><b>重点来了</b></font>：公平锁只会让这个被唤醒的Thread去获取锁，而与其竞争的线程（此时恰好有其它线程突然也跑来获取这个资源）只会被添加到队列的tail，作为尾节点，一直睡眠到前面的都释放了，才会被唤醒尝试获得锁（前提是这个线程是Lock后被添加到同步队列中而不是trylock）</div><div>                非公平则是这个被唤醒的Thread和其他进来获取资源的Thread进行争夺，这时就不会保证被唤醒的线程一定会获取到锁，相反其获取到锁的概率会比较小，因为Release的源码是先释放锁，再去唤醒它的下一个节点。别人是释放锁直接获取，你是释放锁之后再去唤醒你，然后才是获取，自然就慢了，造成饥饿锁情形出现，但是也有好处，就是提高了效率，确保唤醒的线程获取到锁会经过以下操作，浪费时间。直接放源码了，步骤原理，在后面实现lock时进行讲解。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">final boolean acquireQueued(final Node node, int arg) {</span></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">    boolean failed = true;</span></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">    try {</span></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">        boolean interrupted = false;</span></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">        for (;;) {</span></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">            final Node p = node.predecessor();</span></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">            if (p == head &amp;&amp; tryAcquire(arg)) {</span></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">                setHead(node);</span></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">                p.next = null; // help GC</span></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">                failed = false;</span></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">                return interrupted;</span></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">            }</span></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">                parkAndCheckInterrupt())//</span><span style="font-family: Consolas; font-size: 13pt;"><font color="#E30000"><b>唤醒的线程在这儿被唤醒后，会继续通过这个死循环进行获取锁，先获取上一节点，再判断是否为head，再去执行                                             //tryacquire，<span style="font-weight: bold; color: rgb(227, 0, 0); font-family: Consolas; font-size: 13pt;">唤醒线程获得锁之后，还要进行set操作等等后续操作。</span>而</b></font></span><b style="color: rgb(227, 0, 0); font-family: Consolas; font-size: 13pt;"> 非公平锁直接就tryacquire效率会很高</b></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">              interrupted = true;</span> <span style="font-family: Consolas; font-size: 13pt;"><font color="#D100FF"><b>//（本来以为是切换上下文资源，可是对于同一个进程下，切换不同的线程是不需要切换上下文的）</b></font></span></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">        }</span></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">    } finally {</span></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">        if (failed)</span></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">            cancelAcquire(node);</span></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">    }</span></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">}</span></div></div><div><br/></div><div>那么公平锁如何实现唤醒的线程能够获得锁呢？其实很简单，使和唤醒的线程竞争的其它线程获取不到锁，那么你效率再差，那么唤醒的线程就能获取到锁了，使得效率变低了（本来其它的线程都要获取到锁了，却因不是同步队列唤醒的第一个被阻止了，只能慢慢等到唤醒的线程获取到锁，导致效率低）</div><div><b><font style="color: rgb(227, 0, 0);">三个方面（个人认为）</font></b></div><div>还是上代码：<br/></div><div>1：lock获取锁时，不管公平锁还是非公平锁都会调用AQS中的acquire，再调用各自的tryqcquire获取锁，但是两者在调用acquire之前的操作是不一样的，这也是公平性 的区别。</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><br/></div><div><br/></div><div><font style="font-size: 12pt;">final void lock() {     <b><font style="color: rgb(227, 0, 0);">  //这是非公平锁，在lock时，会先进行compareAndSetState（在这儿就没有公平性），失败才会调用acquire，从而调用tryacquire。</font></b></font></div><div><font style="font-size: 12pt;">if (compareAndSetState(0, 1))</font></div><div><font style="font-size: 12pt;">setExclusiveOwnerThread(Thread.currentThread());</font></div><div><font style="font-size: 12pt;">else</font></div><div><font style="font-size: 12pt;">acquire(1);</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><br/></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">final void lock() {</span><span style="font-size: 12pt;"><font color="#E30000"><b>//这是公平锁，在lock时，会直接进行acquire，而不是<span style="font-size: 12pt; font-family: Monaco;">compareAndSetState</span></b></font></span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">    acquire(1);</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">}</span></div></div><div><br/></div><div>2：在调用AQS的acquire时，都会调用到各自的tryacquire，这就是真正的公平性体现地方了</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">protected final boolean tryAcquire(int acquires) {</span></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">        final Thread current = Thread.currentThread();</span></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">        int c = getState();</span></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">        if (c == 0) {</span></div><div><span style="font-family: Consolas; font-size: 13pt;"><font style="color: rgb(0, 0, 128);">            if (!hasQueuedPredecessors() &amp;&amp;//</font><b><font color="#E30000">这就是公平锁确保唤醒的线程能获取到锁的原因，其它的线程在这儿返回true，获取不到</font></b></span></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">                compareAndSetState(0, acquires)) {</span></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">                setExclusiveOwnerThread(current);</span></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">                return true;</span></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">            }</span></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">        }</span></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">        else if (current == getExclusiveOwnerThread()) {</span></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">            int nextc = c + acquires;</span></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">            if (nextc &lt; 0)</span></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">                throw new Error(&quot;Maximum lock count exceeded&quot;);</span></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">            setState(nextc);</span></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">            return true;</span></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">        }</span></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">        return false;</span></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">    }</span></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">}</span></div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;"><font color="#000080">public final boolean</font> <font color="#E30000"><b>hasQueuedPredecessors</b></font><font color="#000080">() {</font><font color="#E30000"><b>//判断这个获取锁的线程是否是等待时间最长的或者这个队列是否为空，只有这两种情况返回false，没有人比我等的时间还长</b></font></font></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">    // The correctness of this depends on head being initialized</font></span></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">    // before tail and on head.next being accurate if the current</font></span></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">    // thread is first in queue.</font></span></div><div><br/></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">    Node t = tail; // Read fields in reverse initialization order</font></span></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">    Node h = head;</font></span></div><div><font style="font-size: 12pt;"><font color="#000080">    Node s;</font><span style="color: rgb(0, 0, 128); font-family: Monaco; font-size: 12pt;">   </span><span style="font-family: Monaco; font-size: 12pt;"><font color="#DE5700"><b>//  h==t,则是空队列，那么这个正在获取锁的一定能获取到锁，返回false，如果队列不为空，就一定要保证这个唤醒线程获得锁了</b></font></span></font></div><div><span style="font-family: Monaco; font-size: 12pt;"><font color="#DE5700"><b>                      //不为空，由于&amp;&amp;是短路的，进行右边判断。</b></font></span></div><div><span style="font-family: Monaco; font-size: 12pt;"><font color="#DE5700"><b>                     //h.next就是被唤醒的线程，s.thread和正在获取锁的thread不一致，返回true，你就获取不到锁了</b></font></span></div><div><font style="font-size: 12pt;"><font color="#000080">    return h != t &amp;&amp;         //</font><font color="#E30000"><b>（只有返回的是false才会获取到锁）</b></font></font></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">        ((s = h.next) == null || s.thread != Thread.currentThread());</font></span></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">}</font></span></div><div><br style="color: rgb(0, 0, 128);"/></div><div><br style="color: rgb(0, 0, 128);"/></div></div><div><br/></div><div>3：还记得上面的公平性效率问题吗？在那儿也体现了公平性，但是此公平性的体现，并不指是公平锁和非公平锁的区别</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);"><br/></span></div><div><font color="#E30000"><b>//此方法用于竞争失败的Thread在添加到同步队列之后，会继续执行接下来方法</b></font></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">final boolean acquireQueued(final Node node, int arg) {</span></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">    boolean failed = true;</span></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">    try {</span></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">        boolean interrupted = false;</span></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">        for (;;) {</span></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">            final Node p = node.predecessor();</span></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">            if (p == head &amp;&amp; tryAcquire(arg)) {</span><span style="font-family: Consolas; font-size: 13pt;"><font color="#E30000"><b>//<span style="font-family: Consolas; font-size: 13pt;">公平性还体现在这儿</span>（其实这是同步队列的公平性，不管是非公平还是公平锁，这儿都会保证同步队列的公平性，</b></font></span></div><div><span style="font-family: Consolas; font-size: 13pt;"><font color="#E30000"><b>                                               //先进先出，真要说是公平锁的公平可能有点问题，主要是体现了公平性），只有你的上一个节点是head你才能尝试获取                                                   //锁，否则就去睡觉去。<span style="font-family: Consolas; font-size: 13pt;">parkAndCheckInterrupt（）会让你去睡觉阻塞，也就是上面的在这儿被唤醒。</span></b></font></span></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">                setHead(node);</span></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">                p.next = null; // help GC</span></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">                failed = false;</span></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">                return interrupted;</span></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">            }</span></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span></div><div><span style="font-family: Consolas; font-size: 13pt;"><font color="#000080">                parkAndCheckInterrupt())/</font><b><font color="#E30000">/唤醒的线程在这儿被唤醒后，会继续通过这个死循环进行获取锁，先获取上一节点，再判断是否为head，再去执行tryacquire，而</font></b></span></div><div><span style="font-family: Consolas; font-size: 13pt;"><font color="#000080">                                       </font><b><font color="#E30000"> // 非公平锁直接就tryacquire效率会很高，而且唤醒线程获得锁之后，还要进行set操作等等后续操作。</font></b></span></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">              interrupted = true;</span></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">        }</span></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">    } finally {</span></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">        if (failed)</span></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">            cancelAcquire(node);</span></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">    }</span></div><div><span style="font-family: Consolas; font-size: 13pt; color: rgb(0, 0, 128);">}</span></div></div><div><br/></div><div>ok，现在来看看lock的整个流程及其源码分析：（<font style="color: rgb(227, 0, 0);"><b>可重入特性也在这儿体现</b></font>）</div><div>手画一张Rentrantlock的lock实现过程（lock主要是添加了获取失败了，调用AQS生成一个同步队列）</div><div>lock的主要流程：</div><div><img src="ReebtrantLock源码分析_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>再来看看同步队列的生成：（有两个比较有意思的小地方，生成节点添加队列时，如果队列为空，会先生成一个空节点作为HEAD节点，第二个是添加队列时会先保证prev指向tail，再通过cas设置tail，最后设置原tail的next指向添加节点，保证了并发时的prev正确性，一定要保证这个。为后面的唤醒做准备）</div><div><img src="ReebtrantLock源码分析_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>下面就直接通过代码对这个流程一一进行剖析</div><div>就直接以NonfailSync 非公平锁 进行原型解析了：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;"><font color="#000080">static final class</font> <font color="#E30000"><b>NonfairSync</b></font> <font color="#000080">extends Sync {</font></font></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">    private static final long serialVersionUID = 7316153563782823691L;</font></span></div><div><font style="font-size: 12pt;"><br style="color: rgb(0, 0, 128);"/></font></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">    /**</font></span></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">     * Performs lock.  Try immediate barge, backing up to normal</font></span></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">     * acquire on failure.</font></span></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">     */</font></span></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">    final void lock() {</font></span></div><div><font style="font-size: 12pt;"><font color="#000080">        if (compareAndSetState(0, 1))</font><font color="#E30000">//在前面公平性已经说了，非公平锁会直接CAS设置，看能不能获取到</font></font></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">            setExclusiveOwnerThread(Thread.currentThread());</font></span></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">        else</font></span></div><div><font style="font-size: 12pt;"><font color="#000080">            acquire(1);</font><font color="#E30000">//接下来就会调用AQS的acquire方法了</font></font></div><div><font color="#E30000" style="font-size: 12pt;">    }</font></div></div><div><br/></div><div>假设没有获取到锁（获取到了就没下面步骤进行分析了），会调用AQS的acquire方法</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><font color="#808080">public final void</font> <font color="#E30000"><b>acquire</b></font><font color="#808080">(int arg) {</font></font></div><div><font style="font-size: 12pt;"><font color="#808080">    if (!tryAcquire(arg) &amp;&amp; </font> <font color="#E30000"><b>//会先调用reentrantlock的内部类重写的tryacquire方法，获取锁</b></font></font></div><div><font style="font-size: 12pt;"><font style="color: rgb(128, 128, 128);">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</font><font color="#E30000"><b>//获取到锁也就不执行下面的了，只有没有获取到锁，才会执行&amp;&amp;左面的方法，添加队列，尝试获取锁，是否进入等待阻塞状态</b></font></font></div><div><span style="color: rgb(128, 128, 128);"><font style="font-size: 12pt;">        selfInterrupt();</font></span></div><div><span style="color: rgb(128, 128, 128);"><font style="font-size: 12pt;">}</font></span></div></div><div>先来看看非公平锁的tryacquire</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 14pt;">protected final boolean tryAcquire(int acquires) {</font></span></div><div><font style="font-size: 14pt;"><font color="#000080">    return nonfairTryAcquire(acquires);</font><b><font color="#E30000">//调用父类的<span style="font-size: 14pt; font-family: Monaco;">nonfairTryAcquire方法，公平锁会自己实现<span style="font-size: 14pt; font-family: Monaco;">tryAcquire</span></span></font></b></font></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 14pt;">}</font></span></div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;"><font color="#000080">final boolean nonfairTryAcquire(int acquires) {</font><font color="#E30000"><b>//父类syc的<span style="font-size: 12pt; font-family: Monaco;">nonfairTryAcquire</span></b></font></font></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">    final Thread current = Thread.currentThread();</font></span></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">    int c = getState();</font></span></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">    if (c == 0) {</font></span></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">        if (compareAndSetState(0, acquires)) {</font></span></div><div><font style="font-size: 12pt;"><font color="#000080">            setExclusiveOwnerThread(current);   </font> <font color="#E30000"><b>//仍然是日常尝试获取锁操作</b></font></font></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">            return true;</font></span></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">        }</font></span></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">    }</font></span></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">    else if (current == getExclusiveOwnerThread()) {</font></span></div><div><font style="font-size: 12pt;"><font color="#000080">        int nextc = c + acquires;               </font> <font color="#E30000"><b>     //这儿是可重入的地方，获得锁的可以再进去，state➕1就可以，进几次加几次，释放锁也要相应的释放次数</b></font></font></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">        if (nextc &lt; 0) // overflow</font></span></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">            throw new Error(&quot;Maximum lock count exceeded&quot;);</font></span></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">        setState(nextc);</font></span></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">        return true;</font></span></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">    }</font></span></div><div><font style="font-size: 12pt;"><font color="#000080">    return false;           </font> <b><font color="#E30000"> //没有获取到锁</font></b></font></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">}</font></span></div></div><div>现在就把acquire的tryacquire进行分析完全了，由于没有获取到锁，进入<span style="font-size: 12pt;"><font style="color: rgb(227, 0, 0);"><b> acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</b></font></span><span style="font-size: 12pt;"><b><font style="color: rgb(227, 0, 0);">)</font></b><font color="#808080">方法</font></span></div><div><span style="font-size: 12pt;"><font><font color="#808080">先来分析里面的参数</font><span style="color: rgb(227, 0, 0); font-size: 12pt; font-weight: bold;">addWaiter(Node.EXCLUSIVE)</span><span style="font-size: 12pt;">此方法是将获取锁失败的线程包装成一个Node节点，添加到同步队列中去。</span></font></span></div><div><span style="font-size: 12pt;"><font><span style="font-size: 12pt;"><br/></span></font></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">private Node addWaiter(Node mode) {</span></div><div><span style="font-size: 12pt;"><font color="#000080">    Node node = new Node(Thread.currentThread(), mode)</font><b><font color="#E30000">;//将线程包装为一个Node节点，具体看AQS的内部类Node</font></b></span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">    // Try the fast path of enq; backup to full enq on failure</span></div><div><span style="font-size: 12pt;"><font color="#000080">    Node pred = tail;</font><b><font color="#FF0000">//队列的尾节点</font></b></span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">    if (pred != null) {</span></div><div><span style="font-size: 12pt;"><font color="#000080">        node.prev = pred; </font> <b><font color="#E30000"> //一定要先保证prev节点的正确性</font></b></span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">        if (compareAndSetTail(pred, node)) {</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">            pred.next = node;</span></div><div><span style="font-size: 12pt;"><font color="#000080">            return node;           </font> <b><font color="#E30000">//已经作为尾节点添加进去了</font></b></span></div><div><span style="font-size: 12pt;"><b><font color="#E30000">        }</font></b></span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">    }</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">    enq(node);                  //</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">    return node;</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">}</span></div></div><div>//如果为空就调用enq，都是通过compareAndSetHead保证正确性</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">private Node enq(final Node node) {</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">    for (;;) {                     </span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">        Node t = tail;</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">        if (t == null) {</span> <span style="font-size: 12pt;"><font color="#E30000"><b>// Must initialize  再进行一次判断是否为空，有可能又添加了一个，此时不为空。还有一个主要因素是:在后面等待队列唤醒后，添加到同步队列也是调用这个                           //方法，所以这个方法要对tail是否为空进行判断，才是一个完整的添加。</b></font></span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">            if (compareAndSetHead(new Node())) </span> <span style="font-size: 12pt;"><font style="color: rgb(227, 0, 0);"><b> //为空，创建一个新的节点作为空节点，因为同步队列head一般都是获取到锁的，队列为空时，添加一个节点状态为0的节点 ，在下面                                                   //<span style="font-size: 12pt; color: #e30000; font-weight: bold; font-family: Monaco;">源</span>码分析时，这个节点状态会被设置为-1 。                                                       </b></font></span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">                tail = head;</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">        } else { </span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">            node.prev = t;                      </span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">            if (compareAndSetTail(t, node)) {</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">                t.next = node;</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">                return t;</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">            }</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">        }</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">    }</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">}</span></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;">//添加之后，就调用</font><span style="font-size: 12pt; color: rgb(0, 0, 128);">acquireQueued</span><span style="font-size: 12pt;">尝试获取锁，没有获取到锁就去休眠，进行阻塞。<span style="font-size: 12pt;"><font style="color: rgb(227, 0, 0);"><b>shouldParkAfterFailedAcquire这个方法使得prev指向的节点的waitstatus一定是signal，而不是cancelled（值为1 &gt;0）。</b></font></span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">final boolean acquireQueued(final Node node, int arg) {</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">    boolean failed = true;</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">    try {</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">        boolean interrupted = false;</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">        for (;;) {</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">            final Node p = node.predecessor();</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">            if (p == head &amp;&amp; tryAcquire(arg)) {</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">                setHead(node);</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">                p.next = null; // help GC</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">                failed = false;</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">                return interrupted;</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">            }</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">                parkAndCheckInterrupt())</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">                interrupted = true;</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">        }</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">    } finally {</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">        if (failed)</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">            cancelAcquire(node);</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">    }</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">}</span></div></div><div><span style="font-size: 12pt;"><font color="#808080"><br/></font></span></div><div><span style="font-size: 12pt;"><font color="#808080"><br/></font></span></div><div><span style="font-size: 12pt;"><font color="#808080"><br/></font></span></div><div><span style="font-size: 12pt;"><font color="#808080"><br/></font></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">    int ws = pred.waitStatus;</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">    if (ws == Node.SIGNAL)</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">        /*</span></div><div><span style="font-size: 12pt;"><font color="#000080">         * This node has already set status asking a release </font> <b><font color="#E30000"> //找出上一个节点为SIGNAL的，否则如果&gt;0就去更新prev节点指向最近的一个waitstatus不&gt;0的其实也就是不为 1的                                                                 //节点，此时返回false，由于这个方法所在的方法体是死循环，会再进来，此时不会&gt;0，就去cas设置为signal</font></b></span></div><div><span style="font-size: 12pt;"><b><font style="color: rgb(227, 0, 0);">                                                                //在死循环进来就是signal了，就会执行下面方法，阻塞住了。如果开始状态小于或者是=0就直接设置为signal（在                                                                  //队列为空时添加的head就属于waitstatus=o的情形，也会帮其设置为-1）。这<span style="font-size: 12pt; font-weight: bold; color: #e30000; font-family: Monaco;"> 个节点没有失效，只有为1时，才会</span>                                                                  //<span style="font-size: 12pt; font-weight: bold; color: #e30000; font-family: Monaco;">被 失效</span><span style="font-size: 12pt; font-weight: bold; color: rgb(227, 0, 0); font-family: Monaco;">                 </span>      </font></b></span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">         * to signal it, so it can safely park.</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">         */</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">        return true;</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">    if (ws &gt; 0) {</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">        /*</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">         * Predecessor was cancelled. Skip over predecessors and</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">         * indicate retry.</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">         */</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">        do {</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">            node.prev = pred = pred.prev;</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">        } while (pred.waitStatus &gt; 0);</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">        pred.next = node;</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">    } else {</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">        /*</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">         * need a signal, but don't park yet.  Caller will need to</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">         * retry to make sure it cannot acquire before parking.</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">         */</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">    }</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">    return false;</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">}</span></div></div><div><span style="font-size: 12pt;"><font color="#808080"><br/></font></span></div><div>唤醒后就会尝试获取lock</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">private void setHead(Node node) { //获取之后就会把node设置为head节点</font></span></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">    head = node;</font></span></div><div><font style="font-size: 12pt;"><font color="#000080">    node.thread = null;   </font> <b><font color="#E30000"> //消除thread引用</font></b></font></div><div><font style="font-size: 12pt;"><font color="#000080">    node.prev = null;       </font> <font color="#E30000"><b>  <span style="font-size: 12pt; font-family: Monaco;"> //消除prev引用</span></b></font></font></div><div><font style="font-size: 12pt;"><font color="#000080">}                           </font> <font color="#FF0000"><b>//next引用会在后面thread获取锁后，帮助head节点的next=null，等待fullgc回收</b></font></font></div></div><div><span style="font-size: 12pt;"><font color="#808080"><br/></font></span></div><div><span style="font-size: 12pt;"><font color="#808080"><br/></font></span></div><div><span style="font-size: 12pt;"><font color="#808080"><br/></font></span></div><div><span style="font-size: 12pt;"><font color="#808080">此时一个完整的lock流程就结束了，没获得锁就会通过以上流程加入到队列中，并被阻塞</font></span></div><div><span style="font-size: 12pt;"><font color="#808080"><br/></font></span></div><div><span style="font-size: 12pt;"><font color="#808080">下面就为非公平锁分析一下unlock释放锁源码</font></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;"><br style="color: rgb(128, 128, 128);"/></font></div><div><font style="font-size: 12pt;"><br style="color: rgb(128, 128, 128);"/></font></div><div><font style="font-size: 12pt;"><font color="#808080">public void unlock() {</font><font color="#FF0000"><b>//reentrantLock调用unlock时，还是在调用AQS的release方法</b></font></font></div><div><font color="#FF0000" style="font-size: 12pt;"><b>    sync.release(1);</b></font></div><div><span style="color: rgb(128, 128, 128);"><font style="font-size: 12pt;">}</font></span></div></div><div><span style="font-size: 12pt;"><b><br/></b></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;"><font color="#000000"><b>public final boolean release(int arg) {</b></font></span></div><div><span style="font-size: 12pt;"><font color="#000000"><b>    if (tryRelease(arg)) {         //会先调用syc的tryrelease方法</b></font></span></div><div><span style="font-size: 12pt;"><font color="#000000"><b>        Node h = head;</b></font></span></div><div><span style="font-size: 12pt;"><font color="#000000"><b>        if (h != null &amp;&amp; h.waitStatus != 0)    </b></font></span></div><div><span style="font-size: 12pt;"><font color="#000000"><b>            unparkSuccessor(h);</b></font></span></div><div><span style="font-size: 12pt;"><font color="#000000"><b>        return true;</b></font></span></div><div><span style="font-size: 12pt;"><font color="#000000">    }</font></span></div><div><span style="font-size: 12pt;"><font color="#000000">    return false;</font></span></div><div><span style="font-size: 12pt;"><font color="#000000">}</font></span></div></div><div><span style="font-size: 12pt;"><font color="#808080"><br/></font></span></div><div><span style="font-size: 12pt;"><font color="#808080"><br/></font></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><br style="font-size: 12pt; color: rgb(128, 128, 128);"/></div><div><br style="font-size: 12pt; color: rgb(128, 128, 128);"/></div><div><span style="font-size: 12pt; color: rgb(128, 128, 128);">protected final boolean tryRelease(int releases) {</span></div><div><span style="font-size: 12pt; color: rgb(128, 128, 128);">    int c = getState() - releases;</span></div><div><span style="font-size: 12pt; color: rgb(128, 128, 128);">    if (Thread.currentThread() != getExclusiveOwnerThread())</span></div><div><span style="font-size: 12pt; color: rgb(128, 128, 128);">        throw new IllegalMonitorStateException();</span></div><div><span style="font-size: 12pt; color: rgb(128, 128, 128);">    boolean free = false;</span></div><div><span style="font-size: 12pt; color: rgb(128, 128, 128);">    if (c == 0) {</span></div><div><span style="font-size: 12pt;"><font color="#808080">        free = true;                             </font> <b><font color="#E30000">//释放完全就会使得c==0，重入锁，应该一直减1，减进来的次数，知道c==0.</font></b></span></div><div><span style="font-size: 12pt;"><font color="#808080">        setExclusiveOwnerThread(null);           </font> <b><font color="#FF0000"> //释放线程</font></b></span></div><div><span style="font-size: 12pt; color: rgb(128, 128, 128);">    }</span></div><div><span style="font-size: 12pt; color: rgb(128, 128, 128);">    setState(c);                               </span> <span style="font-size: 12pt;"><font color="#E30000"><b>//更新state ，不需要是CAS设置，因为此时是获取到锁的线程的操作，只有set成功之后，才没哟锁了</b></font></span></div><div><span style="font-size: 12pt; color: rgb(128, 128, 128);">    return free; </span></div><div><span style="font-size: 12pt; color: rgb(128, 128, 128);">}</span></div></div><div><span style="font-size: 12pt;"><font style="color: rgb(128, 128, 128);"><span style="font-size: 12pt; color: rgb(128, 128, 128);">tryRelease执行完后，</span>再回过头来看看release方法</font></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><br style="font-size: 12pt;"/></div><div><span style="font-size: 12pt;">public final boolean release(int arg) {</span></div><div><span style="font-size: 12pt;">    if (tryRelease(arg)) {       </span></div><div><span style="font-size: 12pt;">        Node h = head;</span></div><div><span style="font-size: 12pt;">        if (h != null &amp;&amp; h.waitStatus != 0)    </span></div><div><span style="font-size: 12pt;">            unparkSuccessor(h);        <font color="#E30000"><b>//在释放锁之后就可以去唤醒锁，此时没有任何线程获取到锁了，这也是为什么会出现非公平时，唤醒线程的锁获得锁的概率比较小。</b></font></span></div><div><span style="font-size: 12pt;">        return true;</span></div><div><span style="font-size: 12pt;">    }</span></div><div><span style="font-size: 12pt;">    return false;</span></div><div><span style="font-size: 12pt;">}</span></div></div><div><span style="font-size: 12pt; color: rgb(128, 128, 128);"> unparkSuccessor(h);   是一比较重点的地方了</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><br style="font-size: 12pt; color: rgb(128, 128, 128);"/></div><div><span style="font-size: 12pt; color: rgb(128, 128, 128);">private void unparkSuccessor(Node node) {</span></div><div><span style="font-size: 12pt; color: rgb(128, 128, 128);">    /*</span></div><div><span style="font-size: 12pt; color: rgb(128, 128, 128);">     * If status is negative (i.e., possibly needing signal) try</span></div><div><span style="font-size: 12pt; color: rgb(128, 128, 128);">     * to clear in anticipation of signalling.  It is OK if this</span></div><div><span style="font-size: 12pt; color: rgb(128, 128, 128);">     * fails or if status is changed by waiting thread.</span></div><div><span style="font-size: 12pt; color: rgb(128, 128, 128);">     */</span></div><div><span style="font-size: 12pt; color: rgb(128, 128, 128);">    int ws = node.waitStatus;           </span> <span style="font-size: 12pt;"><font color="#E30000"><b>  //上文提到过，添加队列时，队列为空会先添加一个新的节点 </b></font></span> <span style="font-size: 12pt; color: rgb(128, 128, 128);">  <span style="font-size: 12pt; color: rgb(0, 0, 128); font-family: Monaco;">private Node enq(final Node node) {</span></span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128); font-family: Monaco;">                                                                               </span> <span style="font-size: 12pt; font-family: Monaco;"><font color="#E30000"><b> //这个节点状态为-1，就会唤醒下面的线程，<span style="font-size: 12pt; font-family: Monaco; color: #e30000; font-weight: bold;">本来是0，但是在睡眠时更新为-1</span></b></font></span></div><div><span style="font-size: 12pt; font-family: Monaco;"><font style="color: rgb(227, 0, 0);"><b>                                                                                //，唤醒它的下面状态&lt;=0的 </b></font> <font color="#000080">                                                        for (;;) {</font></span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128); font-family: Monaco;">       <span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span> Node t = tail;</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128); font-family: Monaco;">       <span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span> if (t == null) {</span><span style="font-family: Monaco; font-size: 12pt; color: rgb(128, 128, 128);"> </span></div><div><span style="font-size: 12pt; font-family: Monaco;"><font color="#000080">          </font><span style="color: rgb(0, 0, 128);">    </span><span style="color: rgb(0, 0, 128);">    </span><span style="color: rgb(0, 0, 128);">    </span><span style="color: rgb(0, 0, 128);">    </span><span style="color: rgb(0, 0, 128);">    </span><span style="color: rgb(0, 0, 128);">    </span><span style="color: rgb(0, 0, 128);">    </span><span style="color: rgb(0, 0, 128);">    </span><span style="color: rgb(0, 0, 128);">    </span><span style="color: rgb(0, 0, 128);">    </span><span style="color: rgb(0, 0, 128);">    </span><span style="color: rgb(0, 0, 128);">    </span><span style="color: rgb(0, 0, 128);">    </span><span style="color: rgb(0, 0, 128);">    </span><span style="color: rgb(0, 0, 128);">    </span><span style="color: rgb(0, 0, 128);">    </span><span style="color: rgb(0, 0, 128);">    </span><span style="color: rgb(0, 0, 128);">    </span><span style="color: rgb(0, 0, 128);">    </span><span style="color: rgb(0, 0, 128);">    </span><span style="color: rgb(0, 0, 128);">    </span><span style="color: rgb(0, 0, 128);">    </span><span style="color: rgb(0, 0, 128);">    </span><span style="color: rgb(0, 0, 128);">    </span><span style="color: rgb(0, 0, 128);">    </span><span style="color: rgb(0, 0, 128);">    </span><span style="color: rgb(0, 0, 128);">    </span><span style="color: rgb(0, 0, 128);">    </span><span style="color: rgb(0, 0, 128);">    </span><span style="color: rgb(0, 0, 128);">    </span><span style="color: rgb(0, 0, 128);">    </span><span style="color: rgb(0, 0, 128);">    </span><span style="color: rgb(0, 0, 128);">    </span><span style="color: rgb(0, 0, 128);">    </span><span style="color: rgb(0, 0, 128);">    </span><span style="color: rgb(0, 0, 128);">    </span><span style="color: rgb(0, 0, 128);">    </span><span style="color: rgb(0, 0, 128);">    </span><span style="color: rgb(0, 0, 128);">    </span><span style="color: rgb(0, 0, 128);">    </span><span style="color: rgb(0, 0, 128);">    </span><span style="color: rgb(0, 0, 128);">    </span><font color="#000080"> </font><b><font color="#E30000"> if (compareAndSetHead(new Node())) </font></b></span> <b><font color="#E30000"><span style="font-size: 12pt; font-family: Monaco;">         </span></font></b> <span style="font-size: 12pt; color: rgb(227, 0, 0); font-weight: bold; font-family: Monaco;">           </span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128); font-family: Monaco;">             <span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span>   tail = head;</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128); font-family: Monaco;">      <span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span>  } else { </span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128); font-family: Monaco;">         <span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span>   node.prev = t;                      </span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128); font-family: Monaco;">         <span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span>   if (compareAndSetTail(t, node)) {</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128); font-family: Monaco;">             <span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span>   t.next = node;</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128); font-family: Monaco;">              <span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span>  return t;</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128); font-family: Monaco;">          <span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span>  }</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128); font-family: Monaco;">       <span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span> </span><span> </span><span>    </span><span>    </span> }</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128); font-family: Monaco;">    <span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>  </span><span>    </span>}</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128); font-family: Monaco;"><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span>}</span></div><div><span style="font-size: 12pt; color: rgb(128, 128, 128);">    if (ws &lt; 0) </span></div><div><span style="font-size: 12pt; color: rgb(128, 128, 128);">        compareAndSetWaitStatus(node, ws, 0);</span></div><div><span style="font-size: 12pt; color: rgb(128, 128, 128);">    Node s = node.next;</span></div><div><span style="font-size: 12pt; color: rgb(128, 128, 128);">    if (s == null || s.waitStatus &gt; 0) {</span></div><div><span style="font-size: 12pt; color: rgb(128, 128, 128);">        s = null;</span></div><div><span style="font-size: 12pt; color: rgb(128, 128, 128);">        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)</span></div><div><span style="font-size: 12pt; color: rgb(128, 128, 128);">           </span><span style="font-size: 12pt;"><font color="#E30000"><b> if (t.waitStatus &lt;= 0)</b></font></span></div><div><span style="font-size: 12pt;"><font color="#E30000"><b>                s = t;</b></font></span></div><div><span style="font-size: 12pt; color: rgb(128, 128, 128);">    }</span></div><div><span style="font-size: 12pt; color: rgb(128, 128, 128);">    if (s != null)</span></div><div><span style="font-size: 12pt;"><font color="#808080">    </font><b><font color="#E30000">    LockSupport.unpark(s.thread);      //就会被唤醒，进入到上面源码分析时讲到的阻塞睡眠的地方唤醒，进行获取锁操作</font></b></span></div><div><span style="font-size: 12pt; color: rgb(128, 128, 128);">}</span></div></div><div><span style="font-size: 12pt;"><font color="#808080"><br/></font></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><br style="font-weight: bold; font-size: 12pt; color: rgb(255, 0, 0);"/></div><div><br style="font-weight: bold; font-size: 12pt; color: rgb(255, 0, 0);"/></div><div><span style="font-weight: bold; font-size: 12pt;"><font color="#000000">final boolean acquireQueued(final Node node, int arg) {</font></span></div><div><span style="font-weight: bold; font-size: 12pt;"><font color="#000000">    boolean failed = true;</font></span></div><div><span style="font-weight: bold; font-size: 12pt;"><font color="#000000">    try {</font></span></div><div><span style="font-weight: bold; font-size: 12pt;"><font color="#000000">        boolean interrupted = false;</font></span></div><div><span style="font-weight: bold; font-size: 12pt;"><font color="#000000">        for (;;) {</font></span></div><div><span style="font-weight: bold; font-size: 12pt;"><font color="#000000">            final Node p = node.predecessor();</font></span></div><div><span style="font-weight: bold; font-size: 12pt;"><font color="#000000">            if (p == head &amp;&amp; tryAcquire(arg)) {</font></span></div><div><span style="font-weight: bold; font-size: 12pt;"><font color="#000000">                setHead(node);</font></span></div><div><span style="font-weight: bold; font-size: 12pt;"><font color="#000000">                p.next = null; // help GC</font></span></div><div><span style="font-weight: bold; font-size: 12pt;"><font color="#000000">                failed = false;</font></span></div><div><span style="font-weight: bold; font-size: 12pt;"><font color="#000000">                return interrupted;</font></span></div><div><span style="font-weight: bold; font-size: 12pt;"><font color="#000000">            }</font></span></div><div><span style="font-weight: bold; font-size: 12pt;"><font color="#000000">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</font></span></div><div><span style="font-weight: bold; font-size: 12pt;"><font color="#000000">               </font><font style="color: rgb(227, 0, 0);"> parkAndCheckInterrupt())       //会在这唤醒，死循环，会继续尝试获取锁，公平锁，就会保证一定会获取到的，因为P==head时会tryacquied，而此时没有锁了，就保                                                 //<span style="font-weight: bold; font-size: 12pt; color: #e30000; font-family: Monaco;">证</span>了一定会获取到的</font></span></div><div><span style="font-weight: bold; font-size: 12pt;"><font color="#000000">                interrupted = true;</font></span></div><div><span style="font-weight: bold; font-size: 12pt;"><font color="#000000">        }</font></span></div><div><span style="font-weight: bold; font-size: 12pt;"><font color="#000000">    } finally {</font></span></div><div><span style="font-weight: bold; font-size: 12pt;"><font color="#000000">        if (failed)</font></span></div><div><span style="font-weight: bold; font-size: 12pt;"><font color="#000000">            cancelAcquire(node);</font></span></div><div><span style="font-weight: bold; font-size: 12pt;"><font color="#000000">    }</font></span></div><div><span style="font-weight: bold; font-size: 12pt;"><font color="#000000">}</font></span></div></div><div><span style="font-size: 12pt;"><br/></span></div><div>公平性的和非公平性的也差不多，下面就说说condition了</div><div><span style="font-size: 12pt;">Condition作为renntrantlock的特点，其实也是AQS的内部类，其也为调用Condition的线程提供了一个队列去进行添加，删除（fullgc），对应着await和signal操作。</span></div><div>也涉及到了Node的NEXWaiter属性通过这个使得conditin对应的等待队列各个node节点相连接，引用。</div><div>Node的prev和next就是同步队列的各个Node节点的互相连接，引用。</div><div><br/></div><div>condition主要两个作用，await以及signal，对应等待队列的添加，删除（fullgc）直接通过源码分析了。</div><div><br/></div><div>await的源码分析：</div><div>先看看步骤流程图：</div><div><img src="ReebtrantLock源码分析_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font color="#000000" style="font-size: 12pt;">public final void await() throws InterruptedException {</font></div><div><font color="#000000" style="font-size: 12pt;">    if (Thread.interrupted())</font></div><div><font color="#000000" style="font-size: 12pt;">        throw new InterruptedException();</font></div><div><font color="#000000" style="font-size: 12pt;">    Node node =</font> <font style="font-size: 12pt; color: rgb(255, 0, 0);"><b>addConditionWaiter();  //添加等待节点</b></font></div><div><font color="#000000" style="font-size: 12pt;">    int savedState = fullyRelease(node);</font></div><div><font color="#000000" style="font-size: 12pt;">    int interruptMode = 0;</font></div><div><font style="font-size: 12pt;"><font color="#000000">    while (!</font><b><font color="#E30000">isOnSyncQueue(node)</font></b><font color="#000000">) {      </font><font color="#FF0000"><b>//判断是不是在同步队列里</b></font></font></div><div><font color="#000000" style="font-size: 12pt;">       </font><font color="#FF0000" style="font-size: 12pt;"><b> LockSupport.park(this);        //阻塞住         等待队列和同步队列差不多。都是一个死循环里阻塞，唤醒，这种操作</b></font></div><div><font color="#000000" style="font-size: 12pt;">        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</font></div><div><font color="#000000" style="font-size: 12pt;">            break;</font></div><div><font color="#000000" style="font-size: 12pt;">    }</font></div><div><font color="#000000" style="font-size: 12pt;">    if (</font><font color="#FF0000" style="font-size: 12pt;"><b>acquireQueued(node, savedState)</b></font> <font color="#000000" style="font-size: 12pt;">&amp;&amp; interruptMode != THROW_IE)</font></div><div><font color="#000000" style="font-size: 12pt;">        interruptMode = REINTERRUPT;</font></div><div><font color="#000000" style="font-size: 12pt;">    if (node.nextWaiter != null) // clean up if cancelled</font></div><div><font color="#000000" style="font-size: 12pt;">       </font><font style="font-size: 12pt; color: rgb(255, 0, 0);"><b> unlinkCancelledWaiters();        //同步队列和等待队列互相转换，同步队列里的Node获取锁被await，会添加到等待队列里，然后<span style="font-size: 12pt; color: #ff0000; font-weight: bold; font-family: Monaco;">tryrelase释放锁唤醒下一个Node节点</span></b></font></div><div><span style="font-size: 12pt; color: rgb(0, 0, 0);">    if (interruptMode != 0)           </span> <span style="font-size: 12pt;"><font style="color: rgb(227, 0, 0);"><b> //等待队列唤醒后会先尝试获取到锁，然后把等待队列更新，删除掉（等待队列也是所有引用置为空，同步队列是下一个获取锁的把上一个next节                                          //点引用为空，等gc回收掉）</b></font></span></div><div><font color="#000000" style="font-size: 12pt;">        reportInterruptAfterWait(interruptMode);</font></div><div><font color="#000000" style="font-size: 12pt;">}</font></div><div><br style="color: rgb(0, 0, 128);"/></div><div><br style="color: rgb(0, 0, 128);"/></div><div><br style="color: rgb(0, 0, 128);"/></div><div><br style="color: rgb(0, 0, 128);"/></div></div><div>开始对await里每一个方法进行源码分析</div><div><span style="color: #ff0000; font-size: 12pt; font-weight: bold;">addConditionWaiter添加等待节点分析</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-weight: bold; font-size: 12pt; color: rgb(0, 0, 128);">private Node addConditionWaiter() {</span></div><div><span style="font-weight: bold; font-size: 12pt; color: rgb(0, 0, 128);">    Node t = lastWaiter;                                     </span> <b><span style="font-size: 12pt; color: rgb(0, 0, 128);"> </span><span style="font-size: 12pt;"><font color="#E30000">//等待队列只有nextWaiter作为等待队列Node之间的引用</font></span></b></div><div><span style="font-weight: bold; font-size: 12pt; color: rgb(0, 0, 128);">    // If lastWaiter is cancelled, clean out.</span></div><div><span style="font-weight: bold; font-size: 12pt; color: rgb(0, 0, 128);">    if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) {</span></div><div><span style="font-weight: bold; font-size: 12pt; color: rgb(0, 0, 128);">        unlinkCancelledWaiters(); </span> <span style="font-size: 12pt;"><font color="#E30000"><b>//Node节点不是等待队列，也就是说在为尾节点添加节点时，有可能那个尾节点被唤醒或者其他操作时，不处于等待状态了，要先将原等待队列进行一次                                     //扫描，将不是等待状态的全都删除掉，这个和同步队列不太一样，同步队列只要保证自己的prev节点是tail就可以了，后面的有效性会在后面判断是否                                    //阻塞时判断更新，这是因为同步队列有两个prev和next指针，等待队列只有一个nextwaiter指针，不能够通过prev指针回溯去检查。</b></font></span></div><div><span style="font-weight: bold; font-size: 12pt; color: rgb(0, 0, 128);">        t = lastWaiter;</span></div><div><span style="font-weight: bold; font-size: 12pt; color: rgb(0, 0, 128);">    }</span></div><div><span style="font-weight: bold; font-size: 12pt; color: rgb(0, 0, 128);">    Node node = new Node(Thread.currentThread(), Node.CONDITION);</span></div><div><span style="font-weight: bold; font-size: 12pt; color: rgb(0, 0, 128);">    if (t == null)</span></div><div><span style="font-weight: bold; font-size: 12pt; color: rgb(0, 0, 128);">        firstWaiter = node;         </span> <span style="font-size: 12pt;"><b><font color="#E30000">  //这儿添加的时候，如果是空队列也直接把Node作为首节点，而同步队列是先生成一个空队列作为头部。</font></b></span></div><div><span style="font-size: 12pt;"><font color="#000080" style="font-weight: bold;">    else                           </font> <b><font color="#000080"> </font> <font color="#E30000"> //主要是同步队列默认首节点是获取到锁的，唤醒其next节点，如果开始没有这个缓冲，那么首节点不会被唤醒，尝试获取锁，而等待队列则不同，                                        //signal是直接对</font></b></span><span style="font-family: 宋体;"><font color="#E30000" style="font-size: 12pt;"><b>firstWaiter进行唤醒的，同步队列是唤醒下面一个节点。</b></font></span></div><div><span style="font-weight: bold; font-size: 12pt; color: rgb(0, 0, 128);">        t.nextWaiter = node;       </span> <span style="font-size: 12pt;"><font color="#E30000"><b>//只要设置下一节点指针就可以了，单向链表</b></font></span></div><div><span style="font-weight: bold; font-size: 12pt; color: rgb(0, 0, 128);">    lastWaiter = node;           </span> <b><font color="#E30000"><span style="font-size: 12pt;"> //再更新尾节点指向</span></font></b></div><div><span style="font-weight: bold; font-size: 12pt; color: rgb(0, 0, 128);">    return node;</span></div><div><span style="font-weight: bold; font-size: 12pt; color: rgb(0, 0, 128);">}</span></div></div><div><br/></div><div><br/></div><div>添加进去后就会释放锁了，所以添加节点操作一定是安全的，就不是和同步队列添加时需要CAS设置了，这也是一个区别</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">final int fullyRelease(Node node) {</font></span></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">    boolean failed = true;</font></span></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">    try {</font></span></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">        int savedState = getState(); //这儿释放和前面unlock释放不一样，unlock释放的参数是1，也就是说重入锁需要多次进行release才能释放掉锁，而await是一点要保证不管是不是重                                       //入锁都要保证完全释放掉,所以release参数一定是getstate的参数，就会完全释放掉</font></span></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">        if (release(savedState)) {</font></span></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">            failed = false;</font></span></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">            return savedState;</font></span></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">        } else {</font></span></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">            throw new IllegalMonitorStateException();</font></span></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">        }</font></span></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">    } finally {</font></span></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">        if (failed)</font></span></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">            node.waitStatus = Node.CANCELLED;</font></span></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">    }</font></span></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">}</font></span></div><div><font style="font-size: 12pt;"><br style="color: rgb(0, 0, 128);"/></font></div><div><br style="color: rgb(0, 0, 128);"/></div></div><div><br/></div><div>释放锁之后，此时此线程就没有锁了，那么其他线程机会获得锁，由于release里会有个方法唤醒同步队列的下一个节点，所以就会有接下来的操作，判断添加的节点是否在同步队列中，防止获得锁的线程通过signalall方法又唤醒了。</div><div><br/></div><div>不再同步队列中，就直接把它在等待队列中休眠阻塞，知道别的线程来唤醒，就不上代码了，和前面的同步队列阻塞是一样的</div><div>如果在同步队列中，那么刚刚在等待队列中添加的节点就要被删除掉（也就是去除引用，等待gc回收）</div><div><br/></div><div>在删除掉还会有一个步骤就是尝试获取锁，因为你被唤醒了自然就回去获取锁了，而不是直接把锁给你，失败了，就会和上面lock一样，进入休眠阻塞，等待前面的Node成为ead节点并且释放锁</div><div><br/></div><div>下面就是删除锁的步骤了</div><div><br/></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">private void unlinkCancelledWaiters() {</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">    Node t = firstWaiter;             </span> <span style="font-size: 12pt;"><font color="#E30000"><b>//由于等待节点不是双向链表，只有首尾节点以及nextwaiter进行连接，所以和同步队列里保证有效性有区别的</b></font></span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">    Node trail = null;         </span> <span style="font-size: 12pt;"><font color="#E30000"><b> //先设置一个中间变量 trail作为后面有效性链表的尾节点</b></font></span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);"> </span> <span style="color: rgb(0, 0, 128); font-size: 12pt;">    while (t != null) {       </span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">        Node next = t.nextWaiter;                           </span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">        if (t.waitStatus != Node.CONDITION) {     </span> <span style="font-size: 12pt;"><font color="#E30000"><b>//判断是否是等待状态</b></font></span></div><div><span style="font-size: 12pt;"><font color="#000080">            t.nextWaiter = null;                  </font><span style="font-size: 12pt; font-family: Monaco;"><font color="#000080"> </font> <b><font color="#E30000"> //不是等待状态，就会将其</font></b></span><span style="font-size: 12pt; font-family: Monaco;"><b><font color="#E30000">nextWaiter清除引用，等待gc回收</font></b></span></span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">            if (trail == null)                       </span> <span style="font-size: 12pt;"><font color="#E30000"><b>//再判断下一个节点，由于第一个节点就是错误的，所以此时尾节点仍然是null</b></font></span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">                firstWaiter = next;                   </span><span style="font-size: 12pt;"><font color="#E30000"><b>//那么next节点自然就是首节点了</b></font></span></div><div><span style="color: rgb(0, 0, 128); font-size: 12pt;">            else</span><br/></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">                trail.nextWaiter = next;         </span> <span style="font-size: 12pt;"><font color="#E30000"><b> //如果tail不为空，说明队列已经有尾节点，不为空了，自然就把下一个节点添加到尾节点上。</b></font></span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">            if (next == null)               </span> <span style="font-size: 12pt;"><b><font color="#9C004C"> </font><font color="#E30000">//tail不是尾节点，只是定义的一个中间变量作为尾节点，这样知道最后next为空，队列检查完毕了，就把tail赋值给尾节点lastwaiter了</font></b></span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">                lastWaiter = trail;</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">        }</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">        else</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">            trail = t;</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">        t = next;</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">    }</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">}</span></div><div><br style="font-size: 12pt; color: rgb(0, 0, 128);"/></div><div><br style="font-size: 12pt; color: rgb(0, 0, 128);"/></div></div><div><br/></div><div>同步队列保证有效性是线程添加休眠时，会保证上节点prev的有效性，释放时，会保证next节点有效性。</div><div>等待队列不是双向的，只能一次性<span style="font-size: 12pt; color: rgb(0, 0, 128);">unlinkCancelledWaiters方法</span>解决其整个队列有效性</div><div><br/></div><div>再看下判断是否在同步队列的方法</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">final boolean isOnSyncQueue(Node node) {</font></span></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">    if (node.waitStatus == Node.CONDITION || node.prev == null)</font></span></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">        return false;</font></span></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">    if (node.next != null) // If has successor, it must be on queue</font></span></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">        return true;</font></span></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">    /*</font></span></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">     * node.prev can be non-null, but not yet on queue because</font></span></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">     * the CAS to place it on queue can fail. So we have to</font></span></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">     * traverse from tail to make sure it actually made it.  It</font></span></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">     * will always be near the tail in calls to this method, and</font></span></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">     * unless the CAS failed (which is unlikely), it will be</font></span></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">     * there, so we hardly ever traverse much.</font></span></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">     */</font></span></div><div><font style="font-size: 12pt;"><font color="#000080">    return findNodeFromTail(node);</font> <font color="#FF0000"><b>//主要是这个方法</b></font></font></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">}</font></span></div><div><font style="font-size: 12pt;"><br style="color: rgb(0, 0, 128);"/></font></div><div><br style="color: rgb(0, 0, 128);"/></div><div><br style="color: rgb(0, 0, 128);"/></div></div><div><br/></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">private boolean findNodeFromTail(Node node) {</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">    Node t = tail;   //tail是同步队列尾节点</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">    for (;;) {</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">        if (t == node)       </span> <span style="font-size: 12pt;"><font color="#E30000"><b> //判断等待队列刚添加的节点和同步队列尾节点是否相等，不等就去对同步队列进行后序遍历，查询</b></font></span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">            return true;</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">        if (t == null)</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">            return false;</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">        t = t.prev;</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">    }</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">}</span></div><div><br style="font-size: 12pt; color: rgb(0, 0, 128);"/></div><div><br style="font-size: 12pt; color: rgb(0, 0, 128);"/></div><div><br style="font-size: 12pt; color: rgb(0, 0, 128);"/></div><div><br style="font-size: 12pt; color: rgb(0, 0, 128);"/></div><div><br style="font-size: 12pt; color: rgb(0, 0, 128);"/></div><div><br style="font-size: 12pt; color: rgb(0, 0, 128);"/></div><div><br style="font-size: 12pt; color: rgb(0, 0, 128);"/></div></div><div><br/></div><div>await方法基本介绍完全了，下面介绍一下signal方法</div><div><br/></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;"><font color="#000080">public final void signal() {           </font> <font color="#E30000"><b> //signal主要就是对等待队列的<span style="font-size: 12pt; font-family: Monaco;">firstWaiter进行<span style="font-size: 12pt; font-family: Monaco;">  doSignal(first)。</span></span></b></font></font></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">    if (!isHeldExclusively())</font></span></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">        throw new IllegalMonitorStateException();</font></span></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">    Node first = firstWaiter;</font></span></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">    if (first != null)</font></span></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">        doSignal(first);</font></span></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">}</font></span></div><div><br style="color: rgb(0, 0, 128);"/></div></div><div><br/></div><div><br/></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">private void doSignal(Node first) {</font></span></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">    do {</font></span></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">        if ( (firstWaiter = first.nextWaiter) == null)</font></span></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">            lastWaiter = null;</font></span></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">        first.nextWaiter = null;</font></span></div><div><font style="font-size: 12pt;"><font color="#000080">    } while (!transferForSignal(first) &amp;&amp;         </font> <font color="#E30000"> //一直唤醒，知道等待队列有一个节点唤醒就结束</font></font></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">             (first = firstWaiter) != null);</font></span></div><div><span style="color: rgb(0, 0, 128);"><font style="font-size: 12pt;">}</font></span></div><div><font style="font-size: 12pt;"><br style="color: rgb(0, 0, 128);"/></font></div><div><br style="color: rgb(0, 0, 128);"/></div><div><br style="color: rgb(0, 0, 128);"/></div><div><br style="color: rgb(0, 0, 128);"/></div><div><br style="color: rgb(0, 0, 128);"/></div><div><br style="color: rgb(0, 0, 128);"/></div></div><div>//这就是真正的对等待队列节点唤醒操作了</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">final boolean transferForSignal(Node node) {</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">    /*</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">     * If cannot change waitStatus, the node has been cancelled.</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">     */</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">        return false;</span></div><div><br style="font-size: 12pt; color: rgb(0, 0, 128);"/></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">    /*</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">     * Splice onto queue and try to set waitStatus of predecessor to</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">     * indicate that thread is (probably) waiting. If cancelled or</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">     * attempt to set waitStatus fails, wake up to resync (in which</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">     * case the waitStatus can be transiently and harmlessly wrong).</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">     */</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">    Node p = enq(node);     </span><span style="font-size: 12pt;"><font color="#FF0000"><b>//这儿就是前面说的，等待队列和同步队列的转换，唤醒后，会添加到等待队列中去</b></font></span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">    int ws = p.waitStatus;</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">    if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))   </span> <font color="#E30000"><b><span style="font-size: 12pt;"> </span><span style="font-size: 12pt;"> //如果p是一个取消了的节点（ws&gt;0），或者对p进行CAS设置失败，则唤醒node节点，让node所在线程进入到                                                                         //acquireQueue方法中，重新进行相关操作，也就是此线程添加到等待队列时，会阻塞的地方唤醒，发现此时                                                                     //该节点已经在同步队列中了，就会执行</span><span style="font-family: 宋体;"><font style="font-size: 12pt;">acquireQueued方法，失败就去阻塞，并且设置相关的waitstatus，否则                                                    //的话就获取到锁了</font></span></b></font><div><span style="font-size: 12pt;"><font color="#000080">                                                         </font> <font color="#E30000"><b>   //否则，由于该节点的前驱节点已经是signal状态了，不用在此处唤醒await中的线程，唤醒工作留给CLH队列中前驱节                                                             //点 ，会减少不必要的park以及unpark操作。</b></font></span></div></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">        LockSupport.unpark(node.thread);</span> <span style="font-size: 12pt;"><font color="#FF0000"><b>//这儿就是唤醒操作了</b></font></span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">    return true;</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 128);">}</span></div><div><br style="font-size: 12pt; color: rgb(0, 0, 128);"/></div><div><br style="font-size: 12pt; color: rgb(0, 0, 128);"/></div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>注意的几个地方：</div><div>不管是reenTrantlock还是<span style="color: rgb(0, 0, 0); font-family: 宋体;"><font style="font-size: 12pt;">AbstractQueuedSynchronizer都是对内部类Node或者是sync进行相关操作，这种思想学学。</font></span></div><div><span style="color: rgb(0, 0, 0); font-family: 宋体;"><font style="font-size: 12pt;">同步队列以及等带队列的区别，一个是双向的，使用了Node的prev和next节点，一个是单向的，只使用了Node的nextWaiter节点。</font></span></div><div><span style="color: rgb(0, 0, 0); font-family: 宋体;"><font style="font-size: 12pt;">两个队列的删除也不是传统意义上的list等等删除，通过清除其引用，等待GC回收。</font></span></div><div>两个队列的添加由于其使用场景的变化，同步队列在空队列添加时，会先生成一个节点，添加上去，作为head，然后再添加线程对应的节点、，等待队列则是直接添加节点，在空队列时，没有先添加一个傀儡节点这种操作，只会把其作为firstwaiter。</div><div>两个队列添加时还有一个小区别，等待队列由于添加时是获取锁，安全的，在释放锁后，会判断是否又被唤醒了，唤醒后，会直接对整个等待队列进行有效性的检查，把不是等待状态的全都移除，而同步队列，在添加之后，有一个判断是否应该阻塞的方法中，直接对其prev进行有效性判断，而不是整个队列，在释放锁，唤醒时，才会对其next节点进行有效性判断，这个也是和等待队列的区别，还是在于结构的不同，一个是单向一个是双向。</div><div>还有很多小地方进行学习。。。。。。</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></div></span>
</div></body></html> 